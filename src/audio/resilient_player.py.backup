#!/usr/bin/env python3
"""
Resilient Audio Player with Platform-Aware Audio - Phase 9.8

This module provides a robust audio streaming player with comprehensive
error handling, automatic recovery, and cross-platform audio support.

Features:
- Stream audio from URLs
- Automatic retry on network failures
- Health monitoring and recovery
- Playback controls (play, pause, stop, skip)
- Volume control (0-100%, mute/unmute)
- Position tracking and seeking
- Platform-aware audio (macOS dev, Linux production)

Author: DeadStream Project
Phase: 9.8 - Cross-Platform Audio Support
"""

import sys
import os

# Add project root to path for imports
PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)

import vlc
import time
import threading
from enum import Enum
from src.audio.vlc_config import create_vlc_instance


class PlayerState(Enum):
    """Player state enumeration"""
    STOPPED = 0
    PLAYING = 1
    PAUSED = 2
    BUFFERING = 3
    ERROR = 4


class ResilientPlayer:
    """
    Resilient audio streaming player with automatic recovery
    and platform-aware audio configuration
    """
    
    def __init__(self, debug=False):
        """
        Initialize the player
        
        Args:
            debug: If True, enable verbose VLC output
        """
        # Create platform-aware VLC instance
        self.instance = create_vlc_instance(debug=debug)

        # Create media player
        self.player = self.instance.media_player_new()
        
        # Playlist management
        self.playlist = []
        self.current_index = 0
        
        # State tracking
        self.state = PlayerState.STOPPED
        self.current_url = None
        
        # Health monitoring
        self.health_thread = None
        self.health_running = False
        self.last_position = 0
        self.stuck_count = 0
        
        # Volume state
        self._volume = 50  # Default 50%
        self._muted = False
        self._volume_before_mute = 50
        
        # Apply default volume
        self.player.audio_set_volume(self._volume)
    
    # ========================================================================
    # VOLUME CONTROL METHODS
    # ========================================================================
    
    def get_volume(self):
        """
        Get current volume level
        
        Returns:
            int: Volume level (0-100)
        """
        return self._volume
    
    def set_volume(self, volume):
        """
        Set volume level
        
        Args:
            volume: Volume level (0-100)
            
        Returns:
            bool: True if successful, False otherwise
        """
        # Validate input
        if not isinstance(volume, (int, float)):
            print(f"[ERROR] Volume must be a number, got {type(volume)}")
            return False
        
        # Clamp to valid range
        volume = max(0, min(100, int(volume)))
        
        try:
            # Update VLC volume
            result = self.player.audio_set_volume(volume)
            
            if result == 0:  # Success
                self._volume = volume
                
                # If we were muted and volume is set, unmute
                if self._muted and volume > 0:
                    self._muted = False
                
                print(f"[INFO] Volume set to {volume}%")
                return True
            else:
                print(f"[WARN] VLC returned {result} when setting volume")
                return False
                
        except Exception as e:
            print(f"[ERROR] Failed to set volume: {e}")
            return False
    
    def get_mute(self):
        """
        Check if audio is muted
        
        Returns:
            bool: True if muted, False otherwise
        """
        return self._muted
    
    def mute(self):
        """
        Mute audio output
        
        Returns:
            bool: True if successful, False otherwise
        """
        if self._muted:
            print("[INFO] Already muted")
            return True
        
        try:
            # Save current volume
            self._volume_before_mute = self._volume
            
            # Set volume to 0
            result = self.player.audio_set_volume(0)
            
            if result == 0:  # Success
                self._muted = True
                print("[INFO] Audio muted")
                return True
            else:
                print(f"[WARN] VLC returned {result} when muting")
                return False
                
        except Exception as e:
            print(f"[ERROR] Failed to mute: {e}")
            return False
    
    def unmute(self):
        """
        Unmute audio output (restore previous volume)
        
        Returns:
            bool: True if successful, False otherwise
        """
        if not self._muted:
            print("[INFO] Not currently muted")
            return True
        
        try:
            # Restore previous volume
            result = self.player.audio_set_volume(self._volume_before_mute)
            
            if result == 0:  # Success
                self._muted = False
                self._volume = self._volume_before_mute
                print(f"[INFO] Audio unmuted (volume: {self._volume}%)")
                return True
            else:
                print(f"[WARN] VLC returned {result} when unmuting")
                return False
                
        except Exception as e:
            print(f"[ERROR] Failed to unmute: {e}")
            return False
    
    def toggle_mute(self):
        """
        Toggle mute state
        
        Returns:
            bool: True if now muted, False if now unmuted
        """
        if self._muted:
            self.unmute()
            return False
        else:
            self.mute()
            return True
    
    def volume_up(self, increment=5):
        """
        Increase volume by specified amount
        
        Args:
            increment: Amount to increase (default 5%)
            
        Returns:
            bool: True if successful
        """
        new_volume = min(100, self._volume + increment)
        return self.set_volume(new_volume)
    
    def volume_down(self, increment=5):
        """
        Decrease volume by specified amount
        
        Args:
            increment: Amount to decrease (default 5%)
            
        Returns:
            bool: True if successful
        """
        new_volume = max(0, self._volume - increment)
        return self.set_volume(new_volume)
    
    # ========================================================================
    # PLAYBACK CONTROL METHODS
    # ========================================================================
    
    def load_url(self, url):
        """
        Load a URL for playback
        
        Args:
            url: URL to audio stream
            
        Returns:
            bool: True if loaded successfully
        """
        try:
            print(f"[INFO] Loading URL: {url}")
            
            # Stop any existing playback
            if self.state != PlayerState.STOPPED:
                self.stop()
            
            # Create new media
            media = self.instance.media_new(url)
            
            # Set media options for streaming
            media.add_option(':network-caching=8000')  # 8 second buffer
            
            # Store URL for recovery
            self.current_url = url
            
            # Load into player
            self.player.set_media(media)
            
            print("[PASS] URL loaded successfully")
            return True
            
        except Exception as e:
            print(f"[ERROR] Failed to load URL: {e}")
            self.state = PlayerState.ERROR
            return False
    
    def play(self):
        """Start or resume playback"""
        try:
            if self.current_url is None:
                print("[WARN] No media loaded")
                return False
            
            # If unmuting on play, restore volume
            if self._muted:
                self.unmute()
            
            result = self.player.play()
            
            if result == 0:  # Success
                self.state = PlayerState.PLAYING
                
                # Start health monitoring if not already running
                if not self.health_running:
                    self._start_health_monitor()
                
                print("[PASS] Playback started")
                return True
            else:
                print(f"[FAIL] VLC play() returned {result}")
                return False
                
        except Exception as e:
            print(f"[ERROR] Playback failed: {e}")
            self.state = PlayerState.ERROR
            return False
    
    def pause(self):
        """Pause playback"""
        try:
            self.player.pause()
            self.state = PlayerState.PAUSED
            print("[INFO] Playback paused")
            return True
            
        except Exception as e:
            print(f"[ERROR] Failed to pause: {e}")
            return False
    
    def stop(self):
        """Stop playback and release resources"""
        try:
            # Stop health monitoring
            self._stop_health_monitor()
            
            # Stop playback
            self.player.stop()
            self.state = PlayerState.STOPPED
            self.current_url = None
            
            print("[INFO] Playback stopped")
            return True
            
        except Exception as e:
            print(f"[ERROR] Failed to stop: {e}")
            return False
    
    def get_state(self):
        """Get current player state"""
        return self.state
    
    def get_position(self):
        """
        Get current playback position in milliseconds
        
        Returns:
            int: Position in milliseconds, or 0 if not available
        """
        try:
            pos = self.player.get_time()
            return pos if pos >= 0 else 0
        except:
            return 0
    
    def get_duration(self):
        """
        Get total duration in milliseconds
        
        Returns:
            int: Duration in milliseconds, or 0 if not available
        """
        try:
            dur = self.player.get_length()
            return dur if dur >= 0 else 0
        except:
            return 0
    
    def seek(self, position_ms):
        """
        Seek to specific position
        
        Args:
            position_ms: Position in milliseconds
            
        Returns:
            bool: True if successful
        """
        try:
            self.player.set_time(position_ms)
            print(f"[INFO] Seeked to {format_time(position_ms)}")
            return True
        except Exception as e:
            print(f"[ERROR] Seek failed: {e}")
            return False
    
    def skip_forward(self, seconds=30):
        """
        Skip forward by specified seconds
        
        Args:
            seconds: Number of seconds to skip (default 30)
            
        Returns:
            bool: True if successful
        """
        current = self.get_position()
        new_pos = current + (seconds * 1000)
        return self.seek(new_pos)
    
    def skip_backward(self, seconds=30):
        """
        Skip backward by specified seconds
        
        Args:
            seconds: Number of seconds to skip back (default 30)
            
        Returns:
            bool: True if successful
        """
        current = self.get_position()
        new_pos = max(0, current - (seconds * 1000))
        return self.seek(new_pos)
    
    # ========================================================================
    # HEALTH MONITORING
    # ========================================================================
    
    def _start_health_monitor(self):
        """Start background health monitoring thread"""
        if self.health_running:
            return
        
        self.health_running = True
        self.health_thread = threading.Thread(target=self._health_monitor_loop, daemon=True)
        self.health_thread.start()
        print("[INFO] Health monitor started")
    
    def _stop_health_monitor(self):
        """Stop background health monitoring thread"""
        if not self.health_running:
            return
        
        self.health_running = False
        if self.health_thread:
            self.health_thread.join(timeout=2)
        print("[INFO] Health monitor stopped")
    
    def _health_monitor_loop(self):
        """
        Background thread that monitors playback health
        Detects stuck playback and attempts recovery
        """
        while self.health_running:
            try:
                # Check if we're supposed to be playing
                if self.state == PlayerState.PLAYING:
                    vlc_state = self.player.get_state()
                    
                    # If VLC says we're not playing but we should be
                    if vlc_state != vlc.State.Playing:
                        print(f"[WARN] VLC state mismatch: {vlc_state}")
                        
                        # Try to restart playback
                        print("[INFO] Attempting recovery...")
                        self.player.play()
                    
                    # Check if position is advancing
                    current_pos = self.get_position()
                    if current_pos == self.last_position:
                        self.stuck_count += 1
                        
                        if self.stuck_count > 5:  # Stuck for 5+ seconds
                            print("[WARN] Playback appears stuck, attempting recovery...")
                            self.player.stop()
                            time.sleep(0.5)
                            self.player.play()
                            self.stuck_count = 0
                    else:
                        self.stuck_count = 0
                        self.last_position = current_pos
                
            except Exception as e:
                print(f"[ERROR] Health monitor error: {e}")
            
            time.sleep(1)
    
    def cleanup(self):
        """Clean up resources"""
        print("[INFO] Cleaning up player resources...")
        self._stop_health_monitor()
        self.stop()
        self.player.release()
        print("[PASS] Cleanup complete")


# Convenience function for testing
def format_time(milliseconds):
    """Format milliseconds as MM:SS"""
    if milliseconds < 0:
        return "00:00"
    
    total_seconds = milliseconds // 1000
    minutes = total_seconds // 60
    seconds = total_seconds % 60
    return f"{minutes:02d}:{seconds:02d}"


if __name__ == '__main__':
    print("ResilientPlayer with Platform-Aware Audio")
    print("This module should be imported, not run directly")
    print("See examples/test_cross_platform_audio.py for usage")
